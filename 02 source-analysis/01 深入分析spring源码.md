class A{

}

//实例化后，用变量保存（匿名对象）
A a = new A();

//spring初始化，实例化（控制权）
@Autoried
A a;

//一定要初始化，否则报null
a.execute();

IOC容器（存java bean）
容器用来装东西，eg.装水容器（水桶、杯子）
web容器，用来装servlet

spring控制反转后，最终目的：实现依赖注入。

//依赖链中所有对象，都在IOC容器里初始化
实例化先后顺序：b a c
class C{
    private A a;
    public void func(){
      a.xxx();
    }
}
class A{
    private B b;
}

spring注入方式
setter
构造方法
强制赋值


面向Bean编程：bean oriented programming BOP
依赖注入：dependency injection DI
IOC

如果两个模块间不能满足一定规则（切面就是规则），那就是说这两个模块无法合并组装在一起的。

AOP（解耦）核心思想：
①先要把一个整体给拆了，分别开发；
②等到发布时，再组装到一起运行。

一个切面就有一个规则。
AOP的重点是解耦（面向规则）。

①苹果A、B，各切成两半，A的左边无法和B的右边无缝合并；
②螺丝、螺帽，二者丝纹紧紧咬合才能无缝合并；
③小汽车的轮子大小30，拿大小40的轮子，无法装进去；

④事务（开启一个事务、执行提交事务、事务回滚、关闭事务），这种有规律的东西，可认为它是一个固定的规则，这时可单独具有一定规律的规则单独分离出来，做为一个独立模块。

面向切面就是面向规则编程。

spring用到AOP的地方：
authentication权限认证
logging日志
transctions manager事务
lazy loading懒加载
context process上下文处理
error handler错误跟踪（异常捕获机制）
cache缓存

di
IOC
AOP（核心宗旨：解耦）
spring的核心宗旨：简化开发


代理模式：①事情必须做，自己没时间做或不想做 ；②持有被代理人的引用。
静态、动态代理。
JDK动态代理：
CGLib动态代理：cglib.jar（Code generation library代码生成库）
asm.jar（全称assembly，装配）

工厂模式：1、隐藏复杂的逻辑过程，只关心结果。
既简单工厂、工厂方法、抽象工厂

单例模式：

委派模式：①类似中介（委托机制）；②只有被委托人引用。
要和代理模式区分开。

策略模式：过程不同，结果一样。

原型模式：过程相同，结果不一样。或模板模式（提高开发效率）

源码学习顺序：spring-core、spring-beans、spring-aop、spring-context、spring-tx、spring-orm、spring-web及其他部分。


代理模式：租房中介、火车票黄牛、媒人、经纪人
特点：①执行者、被代理人；②被代理人事情必须做，自己没时间做或不想做；③需获取到被代理人的个人资料。

穷举法

代理模式关心过程，而不是结果。

动态代理至少写了50遍
彻底了解，必须反复重复，每次重复会发现一些新问题

总结：代理人模式最底层->做了一件什么事情呢？字节码重组。

在原始代码加一些东西，编译生成字节码，加载到JVM动态运行。

spring用的比较多的是cglib代理模式。

jdk动态代理是通过接口，而cglib是通过继承。

eg.Son类继承Father，该类是cglib给我们自动生成的。

cglib同样做了字节码重组。这样做的好处：少写几个类、几个接口。
对于使用API的用户来说是无感知的。

每种技术都是有应用场景的，eg.面向接口编程一般对外提供给别人调用，形成一种规范。
AOP搞接口，其实是搞复杂了。

//AOP 解耦(团队开发)
//变相：三层架构（解耦）

代理模式可以做一件什么事情？可在每个方法调用前加一些代码，在方法调用后加一些代码。
AOP:事务代理（声明式事务，哪个方法需要加事务，哪个方法不需要加事务）、日志监听
service方法
开启一个事务(open)

事务的执行(由我们自己的代码完成的)

监听是否有异常，可能需要根据异常类型来决定这个事务是否要回滚，还是继续提交（commit/rollback）。
事务要关闭（close）

spring为什么是优秀框架，它把停留在理论层次的方法论落地了，而且告诉大家怎么用。

-----------------------------------------------------
>工厂模式不关心过程，只关心结果（结果论）。  
过程需隐藏起来。  

>生产者跟消费者要区分开。    
买早餐：面包、牛奶（产品）  
消费者：关心产品保质期、使用效果、价格。不关心面包生产工艺、生产材料。
>>eg.QS(国家卫生组织权威认证)  
ISO9002(国际标准)

>所有的设计模式都来源于生活。  
AOP在现实生活中使用很普遍，解耦，eg.现代工作分工越来越细，专人做专事。  
切面：eg.建房子，找专业的团队；我需要这个东西，你帮我做。  
只要带有解耦功能，都可以认为是切面。切面的具体实现方式：代理。  
AOP是一种思想，可用代理实现。  
AOP 不等于 代理。工厂不算实现AOP。  

>学习思想，指导行为。  
在实际应用中，不会使用简单工厂模式。  
内功、心法，先把任督二脉打通。  
学习设计模式，是要学一个创造性思维，哪种场景适用哪个设计模式(穷举法)。

>如果没有工厂模式，我们写代码既要关心过程，又要关心结果，分工也比较难。把复杂的业务抽离出来。  

- 工厂模式特点：
>隐藏复杂的逻辑处理过程，只关心执行结果。

- 多个if（内部实现逻辑，可能有几千行），生产的产品多时，非常絮乱，维护困难。
```JAVA  
if("BMW".equalsIgnoreCase(name)){
	//几千行业务逻辑
	return new Bmw();
}else if("Benz".equalsIgnoreCase(name)){
    //几千行业务逻辑
	return new Benz();
}else if("Audi".equalsIgnoreCase(name)){
    //几千行业务逻辑
	return new Audi();
}else{
	System.out.println("这个产品产不出来");
	return null;
}
```
- 把几千行的逻辑都抽离到工厂类，相当于动态配置（固定模式的委派）
```JAVA  
public Car getCar(String name){
	if("BMW".equalsIgnoreCase(name)){
		return new BmwFactory().getCar();
	}else if("Benz".equalsIgnoreCase(name)){
		return new BenzFactory().getCar();
	}else if("Audi".equalsIgnoreCase(name)){
		return new AudiFactory().getCar();
	}else{
		System.out.println("这个产品产不出来");
		return null;
	}
}
```
	
-----------------------------------------------------
### 单例模式
- 是什么？为什么要有单例模式？怎么实现？2WH what why how
>①保证系统启动到停止，全过程只会产生一个实例；  
②当在应用中遇到功能性冲突时，需要使用单例模式。

人都有天生的惰性

- 穷举法：
>配置文件：若不是单例（两配置文件内容一样，有一个是浪费的，若不一样，不知道以哪个为准）  
直接上级领导：（若有多个领导，听谁的？）  
每个个体（万千世界，两片叶子，不一样）  

- 单例模式的七种写法：  
??????????
-----------------------------------------------------
### 委派模式
>代理模式案例，租房中介和你，是平等关系，委派模式不一样，但是他们的关系是包含或上下级关系。  
要和代理模式区分开  
2WH  
what：两个角色，受托人，委托人（社会上是平等关系），eg.公司里面项目经理和普通员工（法律上平等，工作的关系，各自的职责不一样）
代理模式，代理过程都是清楚的，委托模式，委派模式不关心过程只关心结果。

项目经理（委托人）：安排任务  
普通员工（受托人）：执行任务

特点：  
①类似于中介功能（委托机制）；  
②持有被委托人的引用；  
③不关心过程，只关心结果。

围绕spring来讲，spring使用最多的，来讲。目的是为了能看懂源码

why：主要目的就是隐藏具体实现逻辑（类似工厂模式，但是实现原理不一样）
how：

IOC容器中，有一个Register的东西（为了告诉容器，在这个类被初始化过程中，需要做很多不同的逻辑处理，需要实现多个任务执行者，分别实现各自的功能）

工厂模式保证结果的多样性，对于用户只是一种方法。

直接看代码，很吃力，容易晕。
设计模式一定要思考，想明白了，才会使用。

①代理模式前后要做增加，委派模式不做任何增加（指定谁处理）；
②代理模式关心过程，委派模式关心结果；

工厂模式和委派模式不一样，工厂制定的是产品，委派制定的是方法（或执行者）。

---
#### 2.5 策略模式
过程不同，但结果一样。

人和目的地：地图导航输入起点、目的地（结果不变），会有多种路线供选择（驾车、公交、步行、骑行->策略）。

策略模式非常简单。

---
#### 2.6 原型模式
（先有个对象-原型，拷贝出来不是同一个，但内容一样）
过程相同，结果不一样；数据内容完全一样。

java的克隆，就是原型模式的实现。

原型模式主要是解决数据的复制问题（成员变量如果很多，要写很多垃圾代码）。

克隆是不走构造方法的。

9种模式
spring-jdbc用模板模式

模板模式：执行流程一样，但中间有些步骤不同。

喝茶过程比较麻烦，机器就产生了，饮料冲泡机。
1、烧开水；
2、准备杯子，把原料放入杯子（人工干预）；
3、用水冲泡；
4、添加辅料（人工干预）。
固定的执行流程就叫模板。

SpringJDBC
	是java规范，各个数据库厂商自己去实现
	1、加载驱动类DriverManager
	2、建立连接
	3、创建语句集(标准语句集、预处理语句集)(语句集？  MySQL、Oracle、SQLServer、Access)
	4、执行语句集
	5、结果集ResultSet 游标
	ORM(?)

目的不是学会用，而是学会怎么去思考。