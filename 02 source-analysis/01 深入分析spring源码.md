class A{

}

//实例化后，用变量保存（匿名对象）
A a = new A();

//spring初始化，实例化（控制权）
@Autoried
A a;

//一定要初始化，否则报null
a.execute();

IOC容器（存java bean）
容器用来装东西，eg.装水容器（水桶、杯子）
web容器，用来装servlet

spring控制反转后，最终目的：实现依赖注入。

//依赖链中所有对象，都在IOC容器里初始化
实例化先后顺序：b a c
class C{
    private A a;
    public void func(){
      a.xxx();
    }
}
class A{
    private B b;
}

spring注入方式
setter
构造方法
强制赋值


面向Bean编程：bean oriented programming BOP
依赖注入：dependency injection DI
IOC

如果两个模块间不能满足一定规则（切面就是规则），那就是说这两个模块无法合并组装在一起的。

AOP（解耦）核心思想：
①先要把一个整体给拆了，分别开发；
②等到发布时，再组装到一起运行。

一个切面就有一个规则。
AOP的重点是解耦（面向规则）。

①苹果A、B，各切成两半，A的左边无法和B的右边无缝合并；
②螺丝、螺帽，二者丝纹紧紧咬合才能无缝合并；
③小汽车的轮子大小30，拿大小40的轮子，无法装进去；

④事务（开启一个事务、执行提交事务、事务回滚、关闭事务），这种有规律的东西，可认为它是一个固定的规则，这时可单独具有一定规律的规则单独分离出来，做为一个独立模块。

面向切面就是面向规则编程。

spring用到AOP的地方：
authentication权限认证
logging日志
transctions manager事务
lazy loading懒加载
context process上下文处理
error handler错误跟踪（异常捕获机制）
cache缓存

di
IOC
AOP（核心宗旨：解耦）
spring的核心宗旨：简化开发


代理模式：①事情必须做，自己没时间做或不想做 ；②持有被代理人的引用。
静态、动态代理。
JDK动态代理：
CGLib动态代理：cglib.jar（Code generation library代码生成库）
asm.jar（全称assembly，装配）

工厂模式：1、隐藏复杂的逻辑过程，只关心结果。
既简单工厂、工厂方法、抽象工厂

单例模式：

委派模式：①类似中介（委托机制）；②只有被委托人引用。
要和代理模式区分开。

策略模式：过程不同，结果一样。

原型模式：过程相同，结果不一样。或模板模式（提高开发效率）

源码学习顺序：spring-core、spring-beans、spring-aop、spring-context、spring-tx、spring-orm、spring-web及其他部分。


代理模式：租房中介、火车票黄牛、媒人、经纪人
特点：①执行者、被代理人；②被代理人事情必须做，自己没时间做或不想做；③需获取到被代理人的个人资料。

穷举法

代理模式关心过程，而不是结果。

动态代理至少写了50遍
彻底了解，必须反复重复，每次重复会发现一些新问题

总结：代理人模式最底层->做了一件什么事情呢？字节码重组。

在原始代码加一些东西，编译生成字节码，加载到JVM动态运行。

spring用的比较多的是cglib代理模式。

jdk动态代理是通过接口，而cglib是通过继承。

eg.Son类继承Father，该类是cglib给我们自动生成的。

cglib同样做了字节码重组。这样做的好处：少写几个类、几个接口。
对于使用API的用户来说是无感知的。

每种技术都是有应用场景的，eg.面向接口编程一般对外提供给别人调用，形成一种规范。
AOP搞接口，其实是搞复杂了。

//AOP 解耦(团队开发)
//变相：三层架构（解耦）

代理模式可以做一件什么事情？可在每个方法调用前加一些代码，在方法调用后加一些代码。
AOP:事务代理（声明式事务，哪个方法需要加事务，哪个方法不需要加事务）、日志监听
service方法
开启一个事务(open)

事务的执行(由我们自己的代码完成的)

监听是否有异常，可能需要根据异常类型来决定这个事务是否要回滚，还是继续提交（commit/rollback）。
事务要关闭（close）

spring为什么是优秀框架，它把停留在理论层次的方法论落地了，而且告诉大家怎么用。

-----------------------------------------------------
>工厂模式不关心过程，只关心结果（结果论）。  
过程需隐藏起来。  

>生产者跟消费者要区分开。    
买早餐：面包、牛奶（产品）  
消费者：关心产品保质期、使用效果、价格。不关心面包生产工艺、生产材料。
>>eg.QS(国家卫生组织权威认证)  
ISO9002(国际标准)

>所有的设计模式都来源于生活。  
AOP在现实生活中使用很普遍，解耦，eg.现代工作分工越来越细，专人做专事。  
切面：eg.建房子，找专业的团队；我需要这个东西，你帮我做。  
只要带有解耦功能，都可以认为是切面。切面的具体实现方式：代理。  
AOP是一种思想，可用代理实现。  
AOP 不等于 代理。工厂不算实现AOP。  

>学习思想，指导行为。  
在实际应用中，不会使用简单工厂模式。  
内功、心法，先把任督二脉打通。  
学习设计模式，是要学一个创造性思维，哪种场景适用哪个设计模式(穷举法)。

>如果没有工厂模式，我们写代码既要关心过程，又要关心结果，分工也比较难。把复杂的业务抽离出来。  

- 工厂模式特点：
>隐藏复杂的逻辑处理过程，只关心执行结果。

- 多个if（内部实现逻辑，可能有几千行），生产的产品多时，非常絮乱，维护困难。
```JAVA  
if("BMW".equalsIgnoreCase(name)){
	//几千行业务逻辑
	return new Bmw();
}else if("Benz".equalsIgnoreCase(name)){
    //几千行业务逻辑
	return new Benz();
}else if("Audi".equalsIgnoreCase(name)){
    //几千行业务逻辑
	return new Audi();
}else{
	System.out.println("这个产品产不出来");
	return null;
}
```
- 把几千行的逻辑都抽离到工厂类，相当于动态配置（固定模式的委派）
```JAVA  
public Car getCar(String name){
	if("BMW".equalsIgnoreCase(name)){
		return new BmwFactory().getCar();
	}else if("Benz".equalsIgnoreCase(name)){
		return new BenzFactory().getCar();
	}else if("Audi".equalsIgnoreCase(name)){
		return new AudiFactory().getCar();
	}else{
		System.out.println("这个产品产不出来");
		return null;
	}
}
```
	
-----------------------------------------------------
### 单例模式
- 是什么？为什么要有单例模式？怎么实现？2WH what why how
>①保证系统启动到停止，全过程只会产生一个实例；  
②当在应用中遇到功能性冲突时，需要使用单例模式。

人都有天生的惰性

- 穷举法：
>配置文件：若不是单例（两配置文件内容一样，有一个是浪费的，若不一样，不知道以哪个为准）  
直接上级领导：（若有多个领导，听谁的？）  
每个个体（万千世界，两片叶子，不一样）  

- 单例模式的七种写法：  
??????????
-----------------------------------------------------