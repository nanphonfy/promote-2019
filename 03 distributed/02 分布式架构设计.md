#### 主流架构模型-SOA架构和微服务架构
>SOA（Service Oriented Architecture），“面向服务的架构”，是一种设计方法，其中包含多个服务，服务间通过相互依赖最终提供一系列功能。  一个服务通常独立存在于进程中。各服务间通过网络调用。  
与SOA相提并论——ESB（企业服务总线），类似一根管道，连接各服务节点。为集成不同系统、不同协议的服务，ESB 做了消息的转化解释和路由，让不同服务互联互通。

- SOA解决的问题
>- 系统集成：系统角度，解决企业系统间的通信问
题，把原先散乱、无规划的系统间网状结构，梳理成
规整、可治理的系统间星形结构，eg.引入ESB、技术规范、服务管理规范。解决核心问题【有序】
>- 系统的服务化：功能角度，把业务逻辑抽象成
可复用、可组装的服务，通过服务编排实现业务的
快速再生。目的：把原先固有的业务功能转变为通用
的业务服务，实现业务逻辑的快速复用。解决
核心问题【复用】
>- 业务的服务化：企业角度，把企业职能抽象成
可复用、可组装的服务，架构：职能化->服务化。前二者从技术层面解决系统调用、功能复用的问题。第三点：业务驱动把一个业务单元封装成一项服务。解决核心问题【高效】

- 微服务架构
>和SOA架构类似,是在SOA上做的升华，强调重点：“业务需彻底组件化和服务化”。  
原有单业务系统拆分为多个可独立开发、设计、运行的小应用。它们之间通过服务完成交互和集成。    
组件：可独立更换和升级的单元，eg.CPU、内存、显卡、硬盘。类比PC作为组件以服务方式构建，只需维护主板和一些外部设备。假如PC需调用CPU计算，只需知道该组件的地址。

- 微服务特征
>①通过服务组件化；  
②按业务能力划分服务和开发团队；  
③去中心化；  
④基础设施自动化（devops、自动化部署）。

- SOA和微服务架构差别
>①微服务不再强调SOA架构的ESB企业服务总线；SOA 的思想：单业务系统内部实现组件化；  
②Docker的出现，为微服务提供了便利，eg.更小的部署单元，可通过Node或SpringBoot启动进程提供服务；
③SOA注重：系统集成，微服务关注：完全分离。

#### 领域驱动设计及业务驱动划分
- 领域驱动设计概念
>DDD（Domain-Driven Design），即开发前通常要进行：①大量业务知识梳理；②软件设计；③开发。  
领域驱动设计基本概念：业务知识梳理中，必会形成某个领域知识，根据领域知识一步步驱动软件设计。

- 为何需DDD
>业务初期：功能简单(CRUD)，系统清晰。  
产品不断迭代和演化，业务越来越复杂，系统也越来越冗余，各模块彼此关联，甚至连作者都很难说清模块的具体功能意图。  
维护代码时，将牵一发而动全身，eg.只想改评价相关功能，却影响创建订单。虽可加大测试保证功能完备性，但当有大量需求并行开发时，改动重叠、恶性循环、疲于奔命修改各种问题。  
一般解决方案：不断重构系统，系统设计随业务成长不断演进。但很难给一个业务上的含义，只能以技术纬度描述。  
问题：接手代码时不知含义或可修改这块通用逻辑来达到某些需求。

- 领域模型追本溯源
>早期领域模型：数据库设计。   
传统项目流程：①讨论需求；②数据库建模；③需求逐步确定间，不断更新数据库设计；④开发阶段，不断
调整设计，eg.有些关系没建、字段少了、表结构不合理；⑤上线。  
此时数据库是项目根本，开发都是围绕着数据模型展开，形成如下：  
>>①service很重（基本包括所有逻辑处理）；  
②POJO作为service层非常重要的实体，会因不同场景做不同的变化和组合，造成pojo模型：失血、贫血、充血（形容领域模型太胖或太瘦）。  
业务变复杂后，数据结构的变化，各模块需修改，经不断演化变得复杂、冗余、耦合度高。  
DDD需考虑的问题：若程序不依赖数据库存储设备，领域模型就得基于程序本身来设计。

- 抽奖设计
>DDD比较抽象,有点像设计模式，很有用又不懂如何用。案例：转盘抽奖，针对功能划分边界：运营管理平台（配置较复杂，频率较低）和用户使用层（使用频率高，对配置无感知）。根据该特点，划分：C端抽奖和M端抽奖两子域，确认C、M端限界上下文后，再对各自上下文内部进行限界上下文划分。
>- 以C端用户为例，划分界限上下文，确认基本需求。
>>①抽奖资格（抽奖机会条件、抽奖次数、活动起始时间）；  
②抽奖奖品（实物、优惠券、理财金、购物卡…）；  
③奖品配置，概率、库存、某些奖品在有限概率下被限制抽几次等；  
④风控对接, 防止薅羊毛。

- 针对产品功能划分边界
>抽奖上下文是整个领域的核心。  
①对活动的限制，活动资格子域：开始/结束时间、可参与次数等；    
②C端存在刷单，根据产品需求定义风控上下文，对活动进行风控；  
③两个领域：抽奖和发放奖品。前者负责根据概率抽奖，后者负责发放选中奖品。

- 细化上下文
>还需进一步梳理上下文间的关系：  
①任务更好拆分（开发可专心投入相关子域上下文）；  
②方便沟通，明确自身上下文和其他上下文间的依赖关系，更好对接。  
>基于上下文进一步细化建模，DDD存在一些定义。

- 实体
>当一个对象由其标识（主键）区分时，称为实体（Entity）。
- 值对象
>当一个对象对事物进行描述，没唯一标识时，称作值对象。
- 聚合根
>属于实体对象，是领域对象中高内聚的核心对象。（聚合根有全局唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象无唯一标识）。

- 领域服务
>一些重要领域行为或操作，可归类为领域服务。实
现全部业务逻辑且通过各种校验手段保证业务的正确性。

- 资源库
>封装基础设施，提供查询和持久化聚合操作。把对象的存储和访问委托给资源库。它不是数据库的封装，而是领域层与基础设施间的桥梁。DDD关心：领域内的模型，不是数据库操作。

- 代码设计
>一般用模块表示一个领域的界限上下文。
```java 
// 抽奖上下文
cn.nanphonfy.bussiness.lottery.*;
// 风控上下文
cn.nanphonfy.bussiness.riskcontrol.*;
// 奖品上下文
cn.nanphonfy.bussiness.prize.*;
// 活动资格上下文
cn.nanphonfy.bussiness.qualification.*;
// 库存上下文
cn.nanphonfy.bussiness.stock.*;
```

- 对模块内的组织结构 
>一般按领域对象、领域服务、领域资源库、防腐层等组织方式定义。

```java 
// 领域对象-值对象
cn.nanphonfy.bussiness.lottery.domain.valobj.*;
// 领域对象-实体
cn.nanphonfy.bussiness.lottery.domain.entity.*;
// 领域对象-聚合根
cn.nanphonfy.bussiness.lottery.domain.aggre
gate.*;
// 领域服务
cn.nanphonfy.bussiness.lottery.service.*;
// 领域资源库
cn.nanphonfy.bussiness.lottery.repo.*;
```

- 领域驱动优点
>很好的解决领域模型到设计模型的同步、演进、映射到代码逻辑。  
①如何抽象出限界上下文，如何分而治之。  
分而治之：把复杂的大规模软件拆分成若干个子模块，每个模块都能独立运行和解决相关问题。且分割后各部分可组装成一个整体。  
抽象：能精简问题空间，且问题越小越易理解，eg.对接支付（抽象纬度：是支付，而不是具体支付方式）；  
②限界上下文可完美匹配微服务要求。系统复杂后，都需用分治来拆解问题。两种方式：技术维度和业务维度。  
技术维度：类似MVC；业务维度：按业务领域划分系统。  
微服务架构更强调从业务维度做分治，DDD也同样着重业务视角。

- 总结
>领域驱动设计类比一种指导思想，是一种软件开发方法，通过DDD可将系统解构更合理，最终满足高内聚低耦合。类似数据库三范式，初学不太理解，有设计经验后慢慢发现三范式带来的好处。同时
也并不一定需严格按照三范式，有些情况可灵活调整。
