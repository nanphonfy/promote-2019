#### 主流架构模型-SOA架构和微服务架构
>SOA（Service Oriented Architecture），“面向服务的架构”，是一种设计方法，其中包含多个服务，服务间通过相互依赖最终提供一系列功能。  一个服务通常独立存在于进程中。各服务间通过网络调用。  
与SOA相提并论——ESB（企业服务总线），类似一根管道，连接各服务节点。为集成不同系统、不同协议的服务，ESB 做了消息的转化解释和路由，让不同服务互联互通。

- SOA解决的问题
>- 系统集成：系统角度，解决企业系统间的通信问
题，把原先散乱、无规划的系统间网状结构，梳理成
规整、可治理的系统间星形结构，eg.引入ESB、技术规范、服务管理规范。解决核心问题【有序】
>- 系统的服务化：功能角度，把业务逻辑抽象成
可复用、可组装的服务，通过服务编排实现业务的
快速再生。目的：把原先固有的业务功能转变为通用
的业务服务，实现业务逻辑的快速复用。解决
核心问题【复用】
>- 业务的服务化：企业角度，把企业职能抽象成
可复用、可组装的服务，架构：职能化->服务化。前二者从技术层面解决系统调用、功能复用的问题。第三点：业务驱动把一个业务单元封装成一项服务。解决核心问题【高效】

- 微服务架构
>和SOA架构类似,是在SOA上做的升华，强调重点：“业务需彻底组件化和服务化”。  
原有单业务系统拆分为多个可独立开发、设计、运行的小应用。它们之间通过服务完成交互和集成。    
组件：可独立更换和升级的单元，eg.CPU、内存、显卡、硬盘。类比PC作为组件以服务方式构建，只需维护主板和一些外部设备。假如PC需调用CPU计算，只需知道该组件的地址。

- 微服务特征
>①通过服务组件化；  
②按业务能力划分服务和开发团队；  
③去中心化；  
④基础设施自动化（devops、自动化部署）。

- SOA和微服务架构差别
>①微服务不再强调SOA架构的ESB企业服务总线；SOA 的思想：单业务系统内部实现组件化；  
②Docker的出现，为微服务提供了便利，eg.更小的部署单元，可通过Node或SpringBoot启动进程提供服务；
③SOA注重：系统集成，微服务关注：完全分离。

#### 领域驱动设计及业务驱动划分
- 领域驱动设计概念
>DDD（Domain-Driven Design），即开发前通常要进行：①大量业务知识梳理；②软件设计；③开发。  
领域驱动设计基本概念：业务知识梳理中，必会形成某个领域知识，根据领域知识一步步驱动软件设计。

- 为何需DDD
>业务初期：功能简单(CRUD)，系统清晰。  
产品不断迭代和演化，业务越来越复杂，系统也越来越冗余，各模块彼此关联，甚至连作者都很难说清模块的具体功能意图。  
维护代码时，将牵一发而动全身，eg.只想改评价相关功能，却影响创建订单。虽可加大测试保证功能完备性，但当有大量需求并行开发时，改动重叠、恶性循环、疲于奔命修改各种问题。  
一般解决方案：不断重构系统，系统设计随业务成长不断演进。但很难给一个业务上的含义，只能以技术纬度描述。  
问题：接手代码时不知含义或可修改这块通用逻辑来达到某些需求。

- 领域模型追本溯源
>早期领域模型：数据库设计。   
传统项目流程：①讨论需求；②数据库建模；③需求逐步确定间，不断更新数据库设计；④开发阶段，不断
调整设计，eg.有些关系没建、字段少了、表结构不合理；⑤上线。  
此时数据库是项目根本，开发都是围绕着数据模型展开，形成如下：  
>>①service很重（基本包括所有逻辑处理）；  
②POJO作为service层非常重要的实体，会因不同场景做不同的变化和组合，造成pojo模型：失血、贫血、充血（形容领域模型太胖或太瘦）。  
业务变复杂后，数据结构的变化，各模块需修改，经不断演化变得复杂、冗余、耦合度高。  
DDD需考虑的问题：若程序不依赖数据库存储设备，领域模型就得基于程序本身来设计。

- 抽奖设计
>DDD比较抽象,有点像设计模式，很有用又不懂如何用。案例：转盘抽奖，针对功能划分边界：运营管理平台（配置较复杂，频率较低）和用户使用层（使用频率高，对配置无感知）。根据该特点，划分：C端抽奖和M端抽奖两子域，确认C、M端限界上下文后，再对各自上下文内部进行限界上下文划分。
>- 以C端用户为例，划分界限上下文，确认基本需求。
>>①抽奖资格（抽奖机会条件、抽奖次数、活动起始时间）；  
②抽奖奖品（实物、优惠券、理财金、购物卡…）；  
③奖品配置，概率、库存、某些奖品在有限概率下被限制抽几次等；  
④风控对接, 防止薅羊毛。

- 针对产品功能划分边界
>抽奖上下文是整个领域的核心。  
①对活动的限制，活动资格子域：开始/结束时间、可参与次数等；    
②C端存在刷单，根据产品需求定义风控上下文，对活动进行风控；  
③两个领域：抽奖和发放奖品。前者负责根据概率抽奖，后者负责发放选中奖品。

- 细化上下文
>还需进一步梳理上下文间的关系：  
①任务更好拆分（开发可专心投入相关子域上下文）；  
②方便沟通，明确自身上下文和其他上下文间的依赖关系，更好对接。  
>基于上下文进一步细化建模，DDD存在一些定义。

- 实体
>当一个对象由其标识（主键）区分时，称为实体（Entity）。
- 值对象
>当一个对象对事物进行描述，没唯一标识时，称作值对象。
- 聚合根
>属于实体对象，是领域对象中高内聚的核心对象。（聚合根有全局唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象无唯一标识）。

- 领域服务
>一些重要领域行为或操作，可归类为领域服务。实
现全部业务逻辑且通过各种校验手段保证业务的正确性。

- 资源库
>封装基础设施，提供查询和持久化聚合操作。把对象的存储和访问委托给资源库。它不是数据库的封装，而是领域层与基础设施间的桥梁。DDD关心：领域内的模型，不是数据库操作。

- 代码设计
>一般用模块表示一个领域的界限上下文。
```java 
// 抽奖上下文
cn.nanphonfy.bussiness.lottery.*;
// 风控上下文
cn.nanphonfy.bussiness.riskcontrol.*;
// 奖品上下文
cn.nanphonfy.bussiness.prize.*;
// 活动资格上下文
cn.nanphonfy.bussiness.qualification.*;
// 库存上下文
cn.nanphonfy.bussiness.stock.*;
```

- 对模块内的组织结构 
>一般按领域对象、领域服务、领域资源库、防腐层等组织方式定义。

```java 
// 领域对象-值对象
cn.nanphonfy.bussiness.lottery.domain.valobj.*;
// 领域对象-实体
cn.nanphonfy.bussiness.lottery.domain.entity.*;
// 领域对象-聚合根
cn.nanphonfy.bussiness.lottery.domain.aggre
gate.*;
// 领域服务
cn.nanphonfy.bussiness.lottery.service.*;
// 领域资源库
cn.nanphonfy.bussiness.lottery.repo.*;
```

- 领域驱动优点
>很好的解决领域模型到设计模型的同步、演进、映射到代码逻辑。  
①如何抽象出限界上下文，如何分而治之。  
分而治之：把复杂的大规模软件拆分成若干个子模块，每个模块都能独立运行和解决相关问题。且分割后各部分可组装成一个整体。  
抽象：能精简问题空间，且问题越小越易理解，eg.对接支付（抽象纬度：是支付，而不是具体支付方式）；  
②限界上下文可完美匹配微服务要求。系统复杂后，都需用分治来拆解问题。两种方式：技术维度和业务维度。  
技术维度：类似MVC；业务维度：按业务领域划分系统。  
微服务架构更强调从业务维度做分治，DDD也同样着重业务视角。

- 总结
>领域驱动设计类比一种指导思想，是一种软件开发方法，通过DDD可将系统解构更合理，最终满足高内聚低耦合。类似数据库三范式，初学不太理解，有设计经验后慢慢发现三范式带来的好处。同时
也并不一定需严格按照三范式，有些情况可灵活调整。

#### 分布式架构基本理论CAP、BASE&应用
>了解理论前，先了解分布式一致性问题。不同业务产品，对数据一致性要求不同，eg.12306一致性要求严格，不能把票卖出，却发现没座位；银行转账（24小时内到账），只要满足最终钱汇出，若钱没汇出，要保证资金不丢。  

- 关于分布式一致性问题
>分布式系统要解决的重要问题：数据的复制（存在延时）。
eg.做数据库读写分离，若客户端C1将值K：V1->V2，但客户端C2无法立即读到最新值，需一段时间后才能读到。

>指分布式环境引入数据复制机制后，不同数据节点间可能出现数据不一致情况。  
对一个副本数据更新时，必须确保能更新其他副本，否则不同副本间的数据将不一致。
>- 方案一：网络延迟，可阻塞同步动作，用户查询时必须等到数据同步后。问题：性能大幅降低。若同步数据较多或较频繁，可能导致整个系统不可用。  
总结：没法找到一种能满足数据一致性、又不影响性能的方案，故产生一致性的级别：  
>①强一致性：要求所写即所读，用户体验好，但
对性能影响大；    
②弱一致性：该级别约束写入后，不承诺：i.立即读到写入值;ii.数据多久达一致，但尽可能保证到某个时间（eg.秒级别）后，数据达一致；  
③最终一致性：是弱一致性的特例，会保证在一定时间内，达到数据一致状态。业界大型分布式系
统常用模型。

- CAP理论
>一个分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）和分区容错性 （Partition tolerance），最多只能同时满足两项。  
一致性：所有节点数据时刻保持同步；  
可用性：每个请求都能接收响应（成功|失败）；  
分区容错：系统应持续提供服务，即使系统内（某节点分区）有消息丢失，eg.交换机失败、网址网络被分成几个子网，形成脑裂、网络延迟或死机……导致某些server与集群其他机器失联。
本质上，CAP理论必须满足分区容错，只能被迫选择前两种。  
总结：CAP不是一个普适性原理和指导思想，仅
适用原子读写——NOSQL，不适用关系型数据库。

- BASE理论
>CAP理论不适合数据库事务（更新一些错误数据导致失败，无论用何高可用方案都是徒劳的，因为数据发生了无法修正的错误。   
XA事务虽保证分布式数据库的ACID特性，但以性能为代价，对并发和响应时间要求较高的电商，很难接受。  
>eBay放宽数据库事务ACID要求，提出BASE（Basically available,soft-state,Eventually Consistent）——系统基本可用、软状态、数据最终一致性。相对于CAP大大降低要求。

- Basically available（基本可用）
>出现不可预知故障时，允许瞬时部分可用性： 
>①eg.淘宝搜索商品，一般在0.5s内返回查询，但由于后端故障导致查询响应变成2s；  
②eg.分片模式的数据库，100W个用户数据分在5个实例上，若破坏一个实例，那可用性还有80%；  
③电商大促，为防访问量激增，部分用户可能会被
引导到降级页面，服务层也可能只提供降级服务。
- 损失部分可用性——soft-state（软状态）
>表示数据存在中间状态且不影响整体可用性，系统允许不同节数据副本间进行数据同步，存在延时。   eg.订单状态：待支付、支付中、支付成功、支付失败。支付中就是一个中间状态，成功后，在支付表中的状态同步给订单状态前，存在一段时间内的不一致。    
- Eventually consistent （数据的最终一致性）  
>表示所有数据副本在一段时间的同步后最终都能达到一致状态。本质：要保证数据最终达到一致，无需实时强一致。  
>>BASE理论核心思想： 即使无法强一致性，都可根据自身业务，采用适当方式使系统最终一致性。