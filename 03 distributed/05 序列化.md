#### 序列化意义
>一般，java对象存在于JVM（内存）运行时，其生命周期不比JVM长。而Java对象序列化能在JVM停止运行后，保存(持久化)对象，将来被重新读取。  
序列化：把对象状态信息->可存储或传输（字节序列）的形式的过程。  
反序列化：序列化逆向过程，把字节数组反序列化为对象。

- 挑战
>序列化算法优劣两指标：①序列化后的数据大小；②速度及系统资源开销（CPU、内存）。  
>Java提供的对象序列化机制存在两问题：
>①序列化数据较大，传输效率低；  
>②其他语言无法识别和对接。

- 实现序列化
>类实现java.io.Serializable接口。  
基于JDK序列化方式：输出流java.io.ObjectOutputStream和输入流 java.io.ObjectInputStream。

```java 
public class NPSerializer implements Serializer{
    @Override
    public <T> byte[] serialize(T obj) {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = null;
        try {
            objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
            objectOutputStream.writeObject(obj);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return byteArrayOutputStream.toByteArray();
    }

    @Override
    public <T> T deserialize(byte[] data) {
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(data);
        ObjectInputStream objectInputStream = null;
        try {
            objectInputStream = new ObjectInputStream(byteArrayInputStream);
            return (T) objectInputStream.readObject();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

public static void main(String[] args) {
    Person person = new Person();
    person.setName("张钰琪");
    person.setIdNo("32348XXX");
    person.setArea("湖北省武汉市");

    NPSerializer serializer = new NPSerializer();
    byte[] serializerBytes =serializer.serialize(person);

    System.out.println(serializer.deserialize(serializerBytes));
    // Person{name='张钰琪', idNo='32348XXX', area='湖北省武汉市'}
}
```
- 序列化高阶认识
>serialVersionUID作用：Java序列化机制通过serialVersionUID验证版本一致性。  
反序列化时，JVM对比传来的字节流中的serialVersionUID与本地实体类是否一致，是则反序列化，否则抛InvalidCastException。  
若没指定serialVersionUID，编译器自动给该class进行摘要算法（类似指纹算法），文件一有更改(类名、方法名等），UID即变化，可保证编号唯一。

- serialVersionUID两种生成
>①默认1L；  
②根据类名、接口名、成员方法及属性等生成64位的哈希字段。

- 静态变量、父类、transient的序列化
```java
// cn.nanphonfy.specialserializer.Person
public class Person extends ParentPerson implements Serializable{
    private String name;
    private String idNo;
    private String area;
    public static String school = "伯克利音乐学院";
    public static int age = 18;
    private transient String birthday;
    ......
}

// cn.nanphonfy.T
public static void main(String[] args) {
    Person person = new Person();
    person.setName("张钰琪");
    person.setIdNo("32348XXX");
    person.setArea("湖北省武汉市");
    person.school = "明日之子水晶舞台";
    person.age = 19;
    person.setCountry("中国");
    person.setBirthday("2001-05-08");
    NPSerializer serializer = new NPSerializer();
    byte[] serializerBytes =serializer.serialize(person);
    Person p = serializer.deserialize(serializerBytes);

    System.out.println(String.format("%s,%s,%s,%s",p.school,p.age,p.getCountry(),p.getBirthday()));
    // 明日之子水晶舞台,19,null,null
}
```
>子类实现了Serializable接口，父类没有，结果如上。
- 结论
>①当父类没实现序列化，子类有实现，反序列化后，无法获取父类属性值；  
②当父类实现序列化，子类自动实现序列化（无需显示实现Serializable）；  
③当实例变量引用其他对象（也实现序列化接口），则都可序列化。
- transient关键字
>作用：控制变量的序列化。加上该关键字，可阻止变量被序列化；反序列化后，transient变量的值被设为默认值。

- 绕开transient机制

```java 
// cn.nanphonfy.specialserializer.Person
/**反序列化对象**/
private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    objectInputStream.defaultReadObject();
    birthday = (String) objectInputStream.readObject();
}

/**序列化对象**/
private void writeObject(ObjectOutputStream objectOutputStream) throws IOException, ClassNotFoundException {
    objectOutputStream.defaultWriteObject();
    objectOutputStream.writeObject(birthday);
}
```
>以上两私有方法，既不属于Object、也不是Serializable，为何能在序列化时被调用？
>>ObjectOutputStream使用反射寻找是否声明了这两个方法（getPrivateMethod），故必须声明为private。

- 序列化存储规则
```java 
public static void main(String[] args) throws IOException {
    String fileName = "person.txt";
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(fileName));
    Person person = new Person();
    person.setName("张钰琪");
    person.setIdNo("32348XXX");
    person.setArea("湖北省武汉市");
    objectOutputStream.writeObject(person);
    objectOutputStream.flush();
    System.out.println(new File(fileName).length());

    objectOutputStream.writeObject(person);
    objectOutputStream.flush();
    System.out.println(new File(fileName).length());
    objectOutputStream.close();
    // 156,161
}
```
>不关闭流的情况，写两次文件，存储大小相差5 字节。Java序列化机制为节省磁盘空间，当写入文件为同一对象时，不会存储对象内容，仅存储引用。

- 序列化的深克隆和浅克隆
>实现Cloneable接口的类具备clone能力，clone 在内存中进行，比new对象性能更好，特别是大对象。

- 浅克隆
>被复制对象的所有变量都与原对象相同，对其他对象的引用仍指向原对象。  
邮件通知：通过浅克隆通知上课时间。

```java 
public static void main(String[] args) throws CloneNotSupportedException {
    Email email = new Email();
    email.setContent("户外补习班上课时间为：周六9:00-12:00");
    Person person = new Person();
    person.setName("张钰琪");
    person.setEmail(email);

    Person person2 = person.clone();
    person2.setName("李泽珑");

    System.out.println(String.format("%s->%s",person.getName(),person.getEmail().getContent()));
    System.out.println(String.format("%s->%s",person2.getName(),person2.getEmail().getContent()));
    /*张钰琪->户外补习班上课时间为：周六9:00-12:00
    李泽珑->户外补习班上课时间为：周六9:00-12:00*/
}
```
>由于p2克隆对象的Email引用地址指向原对象，当把李泽珑上课时间调整为周日9:00-12:00时，影响到了其他人的通知消息。

- 深克隆
>除引用其他对象的变量，被复制对象的所有变量都与原对象相同。深拷贝把复制的对象引用的对象都复制了一遍。

```java 
// cn.nanphonfy.clone.DeepPerson
public class DeepPerson implements Cloneable,Serializable{
private String name;
private String idNo;
private String area;
private Email email;

public DeepPerson deepClone() throws CloneNotSupportedException, IOException, ClassNotFoundException {
    ByteArrayOutputStream arrayOutputStream = new ByteArrayOutputStream();
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(arrayOutputStream);
    objectOutputStream.writeObject(this);

    ByteArrayInputStream arrayInputStream = new ByteArrayInputStream(arrayOutputStream.toByteArray());
    ObjectInputStream inputStream = new ObjectInputStream(arrayInputStream);
    return (DeepPerson) inputStream.readObject();
}
......

// cn.nanphonfy.clone.T
public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException {
    Email email = new Email();
    email.setContent("户外补习班上课时间为：周六9:00-12:00");
    DeepPerson person = new DeepPerson();
    person.setName("张钰琪");
    person.setEmail(email);

    DeepPerson person2 = person.deepClone();
    person2.setName("李泽珑");
    person2.getEmail().setContent("户外补习班上课时间为：周日9:00-12:00");
    System.out.println(String.format("%s->%s",person.getName(),person.getEmail().getContent()));
    System.out.println(String.format("%s->%s",person2.getName(),person2.getEmail().getContent()));
    /*张钰琪->户外补习班上课时间为：周六9:00-12:00
    李泽珑->户外补习班上课时间为：周日9:00-12:00*/
}
```
>原理：把对象序列化输出到一个流中，再把对象从序列化流中读出，该对象即非原对象。

#### 常见序列化技术
- JAVA序列化的优缺点
>优点：JAVA语言提供，方便简单；  
缺点：不支持跨语言处理、性能相对不是很好， 序列化后数据较大。

- XML序列化框架
>XML优点：可读性好，方便阅读和调试。字节码文件较大，效率不高，适用企业级内部系统。语言无
关性，可用于异构系统间的数据交换和协议。eg.webservice。

- JSON序列化框架
>JSON（JavaScript Object Notation），一种轻量级数据交换格式。JSON 字节流更小，可读性好。企业运用最普遍：  
>①Jackson；  
②FastJson；  
③GSON。
>以上Jackson与Fastjson比GSON性能好；Jackson、GSON稳定性比Fastjson好。Fastjson提供的api 更容易使用。

- Hessian序列化框架
>支持跨语言传输的二进制序列化协议，相对于 Java默认序列化机制，具有更好的性能和易用性，支持多语言。Dubbo采用Hessian序列化实现，对
Hessian做了重构，性能更高。

- Protobuf序列化框架
>Google的一种数据交换格式，独立于语言、平台。提供了多种语言实现，eg.Java、C、Go、Python。空间开销小，性能较好， 适用对性能要求高的 RPC调用。

#### Protobuf原理分析
- 核心原理
>使用varint（zigzag）作为编码方式，使用T-L-
V作为存储方式。
- varint编码方式
>是一种数据压缩算法，核心思想：利用 bit位实现数据压缩。eg.对于int32的数字，需4 个字节表示；若采用Varint编码，对于很小的int32数字，则可用1个字节。

定义一个int32字段值为296。
①转化为2进制编码：




- 总结
>Protocol Buffer的性能好，序列化后体积小、速度快，传输效率高：
>a. 编码/解码方式简单（只需简单的数学运算,位移等）；  
b. 数据压缩效果好：独特编码方式，eg.Varint、Zigzag等；T-L-V数据存储方式，减少了分隔符的使用&数据存储得紧凑。  

`各序列化技术的性能比较地址：https://github.com/eishay/jvm-serializers/wiki`

- 序列化技术选型
>技术层面  
>1. 序列化空间开销，即序列化产生的结果大小， 影响传输性能；  
>2. 序列化消耗时间过长影响业务的响应；  
>3. 是否支持跨平台、跨语言；  
>4. 可扩展性/兼容性；  
>5. 技术的流行程度；  
>6. 学习难度和易用性。  

>选型建议  
>1. 性能要求不高，可采用基于XML的SOAP协议；
>2. 对性能有较高要求，Hessian、Protobuf、Thrift、Avro；    
>3. 前后端分离， 或独立对外的api服务，JSON 较好，调试、可读性；    
>4. Avro设计理念偏于动态类型语言。