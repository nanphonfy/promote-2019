#### 序列化意义
>一般，java对象存在于JVM（内存）运行时，其生命周期不比JVM长。而Java对象序列化能在JVM停止运行后，保存(持久化)对象，将来被重新读取。  
序列化：把对象状态信息->可存储或传输（字节序列）的形式的过程。  
反序列化：序列化逆向过程，把字节数组反序列化为对象。

- 挑战
>序列化算法优劣两指标：①序列化后的数据大小；②速度及系统资源开销（CPU、内存）。  
>Java提供的对象序列化机制存在两问题：
>①序列化数据较大，传输效率低；  
>②其他语言无法识别和对接。

- 实现序列化
>类实现java.io.Serializable接口。  
基于JDK序列化方式：输出流java.io.ObjectOutputStream和输入流 java.io.ObjectInputStream。

```java 
public class NPSerializer implements Serializer{
    @Override
    public <T> byte[] serialize(T obj) {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = null;
        try {
            objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
            objectOutputStream.writeObject(obj);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return byteArrayOutputStream.toByteArray();
    }

    @Override
    public <T> T deserialize(byte[] data) {
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(data);
        ObjectInputStream objectInputStream = null;
        try {
            objectInputStream = new ObjectInputStream(byteArrayInputStream);
            return (T) objectInputStream.readObject();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

public static void main(String[] args) {
    Person person = new Person();
    person.setName("张钰琪");
    person.setIdNo("32348XXX");
    person.setArea("湖北省武汉市");

    NPSerializer serializer = new NPSerializer();
    byte[] serializerBytes =serializer.serialize(person);

    System.out.println(serializer.deserialize(serializerBytes));
    // Person{name='张钰琪', idNo='32348XXX', area='湖北省武汉市'}
}
```