
[toc]

#### 发展历史
>1926，第一台计算机：ENIAC，5000次/s加法运算。
- 冯诺依曼模型  
`输入设备->存储器（运算器、控制器）->输出设备`

>20世纪50~60年代，IMB主导大型机时代。  
20 世纪 80 年代（大型机霸主时代），计算机架构向2个方向发展：  
>>①CISC (Complex Instruction Set Computing，微处理器复杂指令集计算) CPU ->便宜， PC；  
②RISC (Reduced Instruction-Set Computer，精简指令集计算机) CPU ->昂贵，企业小型 UNIX 服务器。

- 发展里程碑
>大型主机有超强计算和 I/O 处理能力、稳定性、安全性等，随着计算机发展，缺点：  
①复杂性，培养运维人才成本很高；  
②贵，政府、金融、电信；  
③单点问题；  
④改用小型机、普通PC搭建系统架构。  

- 2009 Alibaba "去 IOE"
>IOE：IBM 小型机、Oracle 、EMC 高端存储。
130517最后一台 IBM小型机在支付宝下线。

- 为什么去 IOE?
>业务的不断发展，数据量和业务量呈爆发性增长，传统集中式Oracle数据库架构（所有数据都集中在
一个数据库，依靠大型高端设备提供高处理能力和扩展性）在扩展性方面遭遇瓶颈。
。

- 分布式系统意义
>①升级单机处理能力的性价比越来越低（CPU、内存、磁盘，垂直扩展，成本高）；  
②单机处理能力存在瓶颈；  
③很难达到稳定性和可用性。

#### 分布式架构常见概念
- 集群
>饭店原来只有一个厨师，切菜洗菜备料炒菜全干。后来客人多了，又请了个厨师（他们的关系是集群），可炒一样的菜。

- 分布式
>为让厨师专心炒菜，请了配菜师切菜、备菜、备料，厨师和配菜师的关系是分布式。一个配菜师也忙不过来，又请了个配菜师，两配菜师关系是集群。

- 节点
>可独立按照分布式协议完成一组逻辑的程序个体。具体项目中，一个节点类比操作系统上的进程。

- 副本(replica/copy)
>①数据副本指在不同节点上持久化同一份数据，当某节点数据丢失时，可从副本读取数据。
是分布式系统中解决数据丢失的唯一手段；  
②服务副本指多节点提供相同服务，通过主从关系实现服务高可用。

- 中间件
>介于应用和系统之间，为开发者提供处理通信、输入输出的一类软件，让用户只关心自己的应用。

#### 架构发展过程
##### 阶段一：单应用架构
>网站初期，单机跑所有程序、软件，此时讲究效率。

##### 阶段二：应用和数据库服务器分离
>若代码层已无法优化，增加机器是比较好的——web和数据库服务器拆分，提高单机负载、容灾能力。

##### 阶段三：应用服务器集群
>通过应用服务器集群将请求分流到各个服务器中，提升负载。此时它们之间没直接交互，都依赖数据库各自对外提供服务。  
该阶段，各种问题慢慢呈现：①请求由谁转发；②若每次访问到的服务器不一样，如何维护session。

##### 阶段三：应用服务器集群
>通过应用服务器集群将请求分流到各个服务器中，提升负载。此时它们之间没直接交互，都依赖数据库各自对外提供服务。  
该阶段，各种问题慢慢呈现：①请求由谁转发；②若每次访问到的服务器不一样，如何维护session。

##### 阶段四：数据库读写分离
>阶段三提升了应用层性能，数据库负载慢慢增大。若单纯把数据库一分为二，会造成数据库不统一问题，故一般先考虑读写分离方式。  
该架构的问题：①主从库间的数据同步（可用mysql自带master-slave主从复制）；②对应数据源的选择 （第三方数据库中间件，eg.mycat）。

##### 阶段五：搜索引擎缓解读库压力
>数据库做读库，对模糊查找效率不好，电商网站中搜索非常核心，做了读写分离也不能有效解决瓶颈。此时需引入搜索引擎，大大提高查询速度。同时也带来些附加问题，eg.维护索引构建。

##### 阶段六：缓存缓解数据库压力
>逐渐出现多用户访问公共内容（热点数据），没必要每次都从数据库取，在应用层用缓存技术，eg.memcache、redis。  
另外， 若想对某些IP用户的访问频率做限制，放内存不合适，放数据库又太麻烦，此时可用Nosql，eg.mongDB。

##### 阶段七：数据库的水平/垂直拆分
>演进过程，交易、商品、用户数据都还在同一数据库，尽管增加缓存、读写分离，但随着数据库压力持续增加（单表过亿），数据库瓶颈仍是最大问题。
>- 垂直拆分：把不同业务数据拆分到不同的数据库；
>- 水平拆分：把同一表的数据拆分到两个或更多个数据库中。原因：某些业务数据量已达到单个数据库瓶颈，此时可将表拆分到多个数据库中。

##### 阶段八：应用拆分
>随着业务发展，应用压力越来越大，工程规模也越来越庞大，此时可考虑应用拆分。  
按领域模型将用户、商品、交易拆分成多个子系统，拆分后，可能有一些相同代码（eg.用户操作，商品和交易都需查询）， 会导致每个系统都会有用户查询访问相关操作（要抽象出来，是一个坑），通过走服务化路线。  
>>各服务间如何远程通信？
通过RPC技术，比较典型：webservice、hessian、http、RMI等。前期可很好地解决各服务间的通信问题，但互联网发展是持续的，故架构演变、优化持续ing...

##### 总结
层级 | 内容| 备注
---|---|---
应用服务层|web应用服务|---
服务治理|服务治理中间件|服务治理：dubbo、spring cloud
领域服务层|订单服务、商品服务...|rabbitmq/kafka、配置中心、定时调度中心
数据治理|数据库治理中间件|mycat/sharding-jdbc、链路调用监控、系统监控
数据服务层|DB|mysql、redis

#### 分布式领域中冯.诺依曼模型的变化
>计算机硬件由运算器、控制器、存储器、输入、输出设备五大部分组成（架构怎么变皆如此）。

- 输入设备的变化
>分布式架构，输入设备分两类：①互相连接的多个节点，接收其他节点传来的信息；②传统人机交互的输入设备。

- 输出设备的变化
>也有两类：①节点向其他节点传输信息；②传统人机交互的输出设备。

- 控制器的变化
>>单机控制器指： CPU 的控制器；  
分布式系统，控制器主要作用：协调或控制节点间的动作和行为。eg.硬件负载均衡器、LVS 软负载、规则服务器等。

- 运算器
>分布式系统的运算器由多个节点组成。运用多个节点的
计算能力来协同完成整体计算任务。

- 存储器
>分布式系统需把承担存储功能的多个节点组成一个整体的存储器。eg.数据库、redis。

#### 分布式系统难点
>更难理解、设计、构建和管理，应用程序的根源问题更难发现。
- 三态
>集中式架构，调用接口返回结果有两种：①成
功；②失败。  
分布式架构，还会出现③超时。

- 分布式事务
>事务是一系列操作的原子性保证。  
单机，能依靠本机的数据库连接和组件轻易地事务控制；  
分布式，业务原子性操作很可能跨服务（导致分布式事务）。eg.A和B操作分别是不同服务下的同一个事务内的操作，A调用B，A若清楚知道B是否成功提交，从而控制自身提交/回滚。但在分布式系统中调用出现了新状态："超时"，A不知道B成功/失败，A该提交本地事务/回滚？这是很难的问题。   
>- 方案一：若强行保证事务一致性，可采取分布式锁，但会①增加系统复杂度；②会增大系统开销；③事务跨越的服务越多，消耗的资源越大，性能越低。故最好的解决方案就是避免分布式事务。  
>- 方案二：重试机制，但重试若不是查询接口，必然涉及到数据库的变更，若第一次调用成功但没返回成功结果，那第二次调用对调用方来说依然是重试，但对于被调用方来说是重复调用。eg.A向B 转账，A-100,B+100，这样会导致A扣了100，而B增加200。该结果不是我们期望的，因此需在写入的接口做幂等设计。多次调用和单次调用是一样的效果。通常可设置一个唯一键，在写入时查询是否已存在，避免重复写入。但幂等设计的前提：服务是高可用的， 否则无论怎么重试都不能返回
明确的结果，调用方会一直等待，虽可限制重试次数，但这已进入异常状态了，甚至到极端情况还需人为补偿处理。  
根据CAP和BASE理论，不可能在高可用分布式情况下做到一致性，一般都是最终一致性保证。

- 负载均衡
>每个服务单独部署，为达高可用，>=2台机
器。一般企业使用普通机器，长期运行宕机概率高，故两台机器能够大大降低服务不可用的可能性。大型项目会采用十几台、上百台来部署一个服务，不仅保证服务的高可用，更提升服务的 QPS，又带来一个问题：请求路由到哪台机器？  
路由算法很多，有DNS路由，若session在本机，还会根据用户id或cookie等信息路由到固定机器。  
现在应用服务器为扩展方便都会设计为无状态的，session会保存到专有的session服务器，故不会涉及到拿不到session的问题。那路由规则是随机获取么？实际情况较复杂，一定范围内随机，但在大的范围也会分为很多个域，eg.异地多机房，跨机房调用开销太大，优先选择同机房服务。
- 一致性
>数据被分散或复制到不同机器上，如何保证各主机间的数据一致性将成为难点。
- 故障独立性
>分布式系统由多个节点组成，整个分布式系统完全出问题的概率是存在的，但更多的是某节点出问题，其他节点都没问题。