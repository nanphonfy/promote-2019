#### 通信协议的核心应用
- 网络领域知识
>a) 协议：TCP、UDP、MULTICAST  
b) IO（BIO、NIO、AIO）  
c) Socket  
d) NIO(Netty/Mina)  
e) 序列化和反序列化  

- 一个http的请求过程
>用TCP传送数据时，数据被送入协议栈中，逐个通过每一层，以比特流送入网络。其中每一层对收到的数据都要增加一些首部信息。
当目的主机收到一个以太网数据帧时，数据开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用。

- 为何有MAC层还要走IP层
>MAC地址好比身份证，身份证号与户口所在地、出生日期有关，和人所在位置（实时移动）无关。  
MAC地址和设备生产商、批次、日期关联，知道设备的MAC，在网络中无法将数据发送给它，除非其与发送方在同一个网络内。  
故要实现机器间的通信，还需IP地址（当前机器在网络中的位置），类似：城市名+道路号+门牌号。通过IP层的寻址，能在任意两台Internet上的机器间传输数据。

![image](https://raw.githubusercontent.com/nanphonfy/note-images/master/promote-2019/distributed/03/HTTP-sending.png)

![image](https://raw.githubusercontent.com/nanphonfy/note-images/master/promote-2019/distributed/03/HTTP-receiving.png)

#### IP协议和TCP/UDP协议
- 协议
>相当于两个需通过网络通信的程序达成某种约定，
规定：报文交换方式和包含意义。  
eg.HTTP为了解决服务器间传递超文本对象的问题，它们在服务器中创建、存储，并由浏览器可视化。

- IP协议
>TCP和UDP是两种最著名的传输层协议，它们都以IP 作为网络层协议。  
IP协议提供一组数据报文服务，每个分组报文都由网络独立处理和分发（像寄送快递）。  
每个IP报文必须包含一个目的地址字段（eg.寄送快递的收件地址，同时包裹可能丢失）。
IP协议："尽力而为"的协议，网络传输过程中，可能会：报文丢失、报文顺序打乱、重复发送等。  

- TCP /IP
>能检测和恢复IP层提供的端到端通信中可能的报文丢失、重复及其他错误。  
特点：  
>>①提供了一个可信赖的字节流通道；  
②是一种面向连接的协议；
>>>使用TCP通信前，两应用间需建立一个TCP连接，两端需完成握手的消息交换。

- UDP/IP
>不会修复IP层产生的错误，而是简单扩展了IP协议"尽力而为"的数据报文服务，使它能在应用间工作，而不是在主机间工作，故使用该协议须考虑报文丢失，顺序混乱的问题。

#### TCP如何可靠传输
- 建立可靠连接
>TCP协议是可靠的，故传输前，需"三次握手"建立一个连接，需客户、服务端发送3个包确认。

- TCP四次挥手协议
>TCP断开连接时,需客户、服务端发送4个包，确认连接的断开。  
客户或服务器均可主动发起挥手(因为TCP是一个全双工协议)，socket编程中，任一方执行close操作即可产生挥手。

- 为何连接是三次握手，关闭是四次挥手
>三次握手：当SERVER端收到CLIENT端的SYN请求报文后，可直接发送SYN+ACK报文。其中ACK报文用来应答，SYN报文用来同步。  
关闭连接时，当SERVER端收到FIN报文时，很可能不立即关闭SOCKET（还有消息没处理完），故只能先回复一个ACK报文，等消息都处理完了，才能发送FIN报文，故需四步握手。

![image](https://raw.githubusercontent.com/nanphonfy/note-images/master/promote-2019/distributed/03/shake-wave-hands.png)

- 流量控制和确认机制
>建立可靠连接后，即可数据传输。通信过程，最重要的是数据包。若数据的传送与接收过程，出现接收方来不及接收，则需对发送方进行控制，避免数据丢失。  
滑动窗口机制可在TCP连接上实现对发送方的流量控
制。TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。

- 滑动窗口协议
>滑动窗口（Sliding Window）是一种流量控制技术。  
早期，通信双方不考虑网络拥挤情况，直接发送数据。由于不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，滑动窗口机制可解决此问题；发送、接受方都会维护一个数据帧的序列，这个序列被称作窗口。

![image](https://raw.githubusercontent.com/nanphonfy/note-images/master/promote-2019/distributed/03/sliding-window.png)

>发送方的窗口大小由接受方确定，目的：①控制发送速度，以免接受方缓存不够，导致溢出；②控制流量也可避免网络拥塞。  
图片的4,5,6号数据帧已被发送，但未收到ACK；7,8,9帧则是等待发送。  
发送端窗口大小为6（接受端告知）。若发送端收到 4号ACK，则窗口左边缘向右收缩，右边缘向右扩
展，窗口向前"滑动"，数据帧10也可被发送。

- 发送窗口
>发送端允许连续发送的幀序号表。  
发送端可不等待应答而连续发送的最大幀数称为发送窗口的尺寸。

- 接收窗口
>接收方允许接收的幀序号表，凡落在接收窗口内的幀，接收方必须处理，落在接收窗口外的幀被丢弃。  
接收方每次允许接收的幀数称为接收窗口的尺寸。

- 在线滑动窗口演示
>https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html

#### 多任务处理、优化
>应用层使用TCP/UDP通信，是基于Socket和DatagramSocket

- 正常通信过程(BIO)
>TCP响应服务器一次只能处理一个客户端请求（被称为"迭代服务器",处理完前一个请求才能对下一个客户端请求A响应）。  
已被某客户端占用的服务器可继续接收新请求发送的数据，但在处理完上个请求数据前，不会对新客户端响应。
java多线程技术，让服务器能处理多客户端请求。

- TCP协议通信过程
>每个TCP Socket的内核中都有一个发送和接收缓冲区（全双工模式与滑动窗口，依赖于两独立Buffer和用户Buffer的填充状态）。  
>- 接收缓冲区：数据缓存到内核，若应用进程一直没调用Socket的read（把内核接收缓冲区的数据复制到应用层的用户Buffer里），会一直被缓存。
>- 发送缓冲区：进程调用Socket的send发送数据，从应用层的用户Buffer复制到Socket的内核发
送缓冲区，然后send返回（返回时，数据不一定被发送到对端）。
>>Socket接收缓冲区用来缓存网络上收到的数据。若一直没读，Buffer满后，通知对端关闭TCP协议中的窗口，保证接收缓冲区不会移除、可靠传输。若对端发出超窗口大小的数据，接收方将丢弃数据。

- 使用非阻塞提高性能
>一般同步的概念是对针客户端的，非阻塞的概念针对服务端。  
非阻塞：解决I/O线程与Socket解耦的问题，引入事件机制来达成。  
可认为NIO底层存在一个I/O调度线程，不断扫描每个Socket缓冲区：①当发现写入缓冲区为空，产生一个Socket可写事件，程序可把数据写入Socket中。若一次写不完，等待下次可写事件通知；②当发现缓冲区有数据，产生一个Socket可读事件，程序可从Socket读取数据。

- NIO
>基于传统BIO模型，探索方法：轮询一组客户端，查找哪个连接需提供服务。

- 缓冲区
>NIO中，所有数据都用缓冲区处理，①读取数据时
，直接读到缓冲区；②写入数据时，写到缓冲区。

- 通道
>Channel通道，像自来水管可读取和写入数据， Channel是全双工的，故数据双向流动。

- 多路复用
>多路复用器Selector是NIO的基础，Selector会不断轮询注册上的Channel。若某Channel有新TCP连接接入、读、写事件，该Channel处于就绪状态会被轮询到，通过SelectionKey获取就绪Channel进行I/O操作。  
一个多路复用器可同时轮询多个Channel。该机制可接入成千上万个客户端。

![image](https://raw.githubusercontent.com/nanphonfy/note-images/master/promote-2019/distributed/03/NIO.png)

- 组播协议:Multicast
>某信息同时传送给多个接受者时，可向每个接受者单播一个数据副本（效率低，浪费带宽）。  
解决方案：把复制数据包的工作交给网络，不由发送者负责。无论多少客户端，都没问题。  
>- 两种分发类型：广播（broadcast）和多播（multicast）
>>广播：网络中所有主机都会接收到一份数据副本；  
多播：消息只发送给一个多播地址，网络只是将数据分发。实现只有UDP最合适。

- 广播
>主机向子网内所有主机发消息，子网内所有主机
都能收到来自某主机的广播信息，属于点对所有点的通信。网络向子网每一个主机都投递一份数据包，不论他们是否乐意接收。

- 多播
>主机向一组主机发送信息，存在于某组的所有主机都可收到消息，属于点对多点的通信。